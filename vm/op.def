OP_GEN(NOP, "nop", N, {
	INSTR++;
	return IVM_ACTION_NONE;
})

OP_GEN(NEW_NULL, "new_null", N, {
	STACK_PUSH(IVM_NULL_OBJ(STATE));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(NEW_OBJ, "new_obj", N, {
	STACK_PUSH(ivm_object_new(STATE));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(NEW_NUM_I, "new_num_i", I, {
	STACK_PUSH(ivm_numeric_new(STATE, ARG));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(NEW_NUM_S, "new_num_s", S, {
	INSTR++;
	return IVM_ACTION_NONE;
})

OP_GEN(NEW_FUNC, "new_func", I, {
	ivm_function_t *func = ivm_vmstate_getFunc(STATE, ARG);

	STACK_PUSH(ivm_function_object_new_nc(STATE, CONTEXT, func));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(GET_SLOT, "get_slot", S, {
	const ivm_char_t *key = ivm_string_pool_get(STRING_POOL, ARG);
	ivm_object_t *obj;

	CHECK_STACK(1);

	obj = ivm_object_getSlotValue(STACK_POP(), STATE, key);
	
	STACK_PUSH(obj ? obj : IVM_UNDEFINED(STATE));

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(SET_SLOT, "set_slot", S, {
	const ivm_char_t *key = ivm_string_pool_get(STRING_POOL, ARG);
	ivm_object_t *obj, *val;

	CHECK_STACK(2);

	obj = STACK_POP();
	val = STACK_POP();
	
	if (obj) {
		ivm_object_setSlot(obj, STATE, key, val);
	}
	
	STACK_PUSH(obj);
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(GET_CONTEXT_SLOT, "get_context_slot", S, {
	const ivm_char_t *key = ivm_string_pool_get(STRING_POOL, ARG);
	ivm_object_t *found = ivm_ctchain_search(CONTEXT, STATE, key);

	STACK_PUSH(found ? found : IVM_UNDEFINED(STATE));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(SET_CONTEXT_SLOT, "set_context_slot", S, {
	const ivm_char_t *key = ivm_string_pool_get(STRING_POOL, ARG);
	ivm_object_t *val;

	CHECK_STACK(1);

	val = STACK_POP();

	if (!ivm_ctchain_setSlotIfExist(CONTEXT, STATE, key, val)) {
		ivm_ctchain_setLocalSlot(CONTEXT, STATE, key, val);
	}

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(SET_ARG, "set_arg", S, {
	const ivm_char_t *key = ivm_string_pool_get(STRING_POOL, ARG);

	ivm_ctchain_setLocalSlot(CONTEXT, STATE, key,
							 AVAIL_STACK >= 1
							 ? STACK_POP()
							 : IVM_UNDEFINED(STATE));

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(POP, "pop", N, {
	CHECK_STACK(1);
	STACK_POP();
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(DUP, "dup", I, {
	ivm_op_arg_t i = ARG;
	CHECK_STACK(i + 1);
	STACK_PUSH(STACK_BEFORE(i));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_OBJ, "print_obj", N, {
	ivm_object_t *obj;

	CHECK_STACK(1);

	obj = STACK_POP();
	IVM_OUT("print: %p\n", (void *)obj);
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_NUM, "print_num", N, {
	ivm_object_t *obj;

	CHECK_STACK(1);

	obj = STACK_POP();
	if (IVM_OBJECT_GET(obj, TYPE_TAG) == IVM_NUMERIC_T)
		IVM_OUT("print num: %f\n", IVM_AS(obj, ivm_numeric_t)->val);
	else
		IVM_OUT("cannot print number of object of type <%s>\n", IVM_OBJECT_GET(obj, TYPE_NAME));

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_TYPE, "print_type", N, {
	ivm_object_t *obj;

	CHECK_STACK(1);

	obj = STACK_POP();
	IVM_OUT("type: %s\n", obj ? IVM_OBJECT_GET(obj, TYPE_NAME) : "empty pointer");
	
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_STR, "print_str", S, {
	IVM_OUT("%s\n", ivm_string_pool_get(STRING_POOL, ARG));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(INVOKE, "invoke", I, {
	ivm_function_object_t *obj;
	ivm_function_t *func;
	ivm_sint32_t arg_count = ARG;
	ivm_vmstack_iterator_t args;
	ivm_object_t *ret;

	CHECK_STACK(arg_count + 1);

	obj = IVM_AS(STACK_POP(), ivm_function_object_t);

	IVM_ASSERT(IVM_IS_TYPE(obj, IVM_FUNCTION_OBJECT_T),
			   IVM_ERROR_MSG_NOT_TYPE("function", IVM_OBJECT_GET(obj, TYPE_NAME)));
	
	func = ivm_function_object_getFunc(obj);
	args = STACK_CUT(arg_count);

	IVM_RUNTIME_SET(RUNTIME, IP, INSTR + 1);

	ivm_function_invoke(func, STATE,
						ivm_function_object_getClosure(obj), CORO);

	if (ivm_function_isNative(func)) {
		ret = ivm_function_callNative(func, STATE, CONTEXT,
									  IVM_FUNCTION_SET_ARG_2(arg_count, args));
		STACK_PUSH(ret ? ret : IVM_NULL_OBJ(STATE));
	} else {
		STACK_INC(arg_count);
	}

	return IVM_ACTION_INVOKE;
})

OP_GEN(YIELD, "yield", N, {
	CHECK_STACK(1);
	INSTR++;

	return IVM_ACTION_YIELD;
})

OP_GEN(JUMP, "jump", I, {
	INSTR += ARG;
	return IVM_ACTION_NONE;
})

OP_GEN(JUMP_TRUE, "jump_true", I, {
	if (ivm_object_toBool(STACK_POP(), STATE)) {
		INSTR += ARG;
	} else {
		INSTR++;
	}

	return IVM_ACTION_NONE;
})

OP_GEN(JUMP_FALSE, "jump_false", I, {
	if (!ivm_object_toBool(STACK_POP(), STATE)) {
		INSTR += ARG;
	} else {
		INSTR++;
	}

	return IVM_ACTION_NONE;
})

OP_GEN(TEST1, "test1", N, {
	IVM_OUT("test1\n");
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(TEST2, "test2", I, { 
	INSTR++;
	return IVM_ACTION_NONE;
})

OP_GEN(TEST3, "test3", S, {
	IVM_OUT("morning! this is test3\n");
	IVM_OUT("string argument: %s\n", ivm_string_pool_get(STRING_POOL, ARG));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(LAST, "last", N, {
	IVM_OUT("LAST\n");
	INSTR++;

	return IVM_ACTION_NONE;
})
