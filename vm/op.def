OP_GEN(NOP, "nop", N, {
	INSTR++;
	return IVM_ACTION_NONE;
})

OP_GEN(NEW_NULL, "new_null", N, {
	STACK_PUSH(IVM_NULL_OBJ(STATE));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(NEW_OBJ, "new_obj", N, {
	STACK_PUSH(ivm_object_new(STATE));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(NEW_NUM_I, "new_num_i", I, {
	STACK_PUSH(ivm_numeric_new(STATE, ARG));
	INSTR++;

	return IVM_ACTION_NONE;
})

/*
OP_GEN(NEW_NUM_S, "new_num_s", S, {
	INSTR++;
	return IVM_ACTION_NONE;
})
*/

OP_GEN(NEW_STR, "new_str", S, {
	STACK_PUSH(ivm_string_object_new(STATE, IVM_TRUE,
									 ivm_string_pool_get(STRING_POOL, ARG)));
	INSTR++;
	return IVM_ACTION_NONE;
})

OP_GEN(NEW_FUNC, "new_func", I, {
	STACK_PUSH(ivm_function_object_new_nc(STATE, CONTEXT,
										  ivm_vmstate_getFunc(STATE, ARG)));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(GET_SLOT, "get_slot", S, {
	ivm_object_t *obj;

	CHECK_STACK(1);

	obj = ivm_object_getSlotValue(STACK_POP(), STATE,
								  ivm_string_pool_get(STRING_POOL, ARG));
	
	STACK_PUSH(obj ? obj : IVM_UNDEFINED(STATE));

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(SET_SLOT, "set_slot", S, {
	ivm_object_t *obj;

	CHECK_STACK(2);

	obj = STACK_POP();
	
	ivm_object_setSlot(obj, STATE,
					   ivm_string_pool_get(STRING_POOL, ARG),
					   STACK_POP());
	
	STACK_PUSH(obj);
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(GET_CONTEXT_SLOT, "get_context_slot", S, {
	ivm_object_t *found =
				  ivm_ctchain_search(CONTEXT, STATE,
									 ivm_string_pool_get(STRING_POOL, ARG));

	STACK_PUSH(found ? found : IVM_UNDEFINED(STATE));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(SET_CONTEXT_SLOT, "set_context_slot", S, {
	const ivm_char_t *key = ivm_string_pool_get(STRING_POOL, ARG);
	ivm_object_t *val;

	CHECK_STACK(1);

	val = STACK_POP();

	if (!ivm_ctchain_setSlotIfExist(CONTEXT, STATE, key, val)) {
		ivm_ctchain_setLocalSlot(CONTEXT, STATE, key, val);
	}

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(SET_ARG, "set_arg", S, {
	ivm_ctchain_setLocalSlot(CONTEXT, STATE,
							 ivm_string_pool_get(STRING_POOL, ARG),
							 AVAIL_STACK >= 1
							 ? STACK_POP()
							 : IVM_UNDEFINED(STATE));

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(POP, "pop", N, {
	CHECK_STACK(1);
	STACK_POP();
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(DUP, "dup", I, {
	ivm_op_arg_t i = ARG;
	CHECK_STACK(i + 1);
	STACK_PUSH(STACK_BEFORE(i));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_OBJ, "print_obj", N, {
	CHECK_STACK(1);

	IVM_OUT("print: %p\n", (void *)STACK_POP());
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_NUM, "print_num", N, {
	ivm_object_t *obj;

	CHECK_STACK(1);

	obj = STACK_POP();
	if (IVM_OBJECT_GET(obj, TYPE_TAG) == IVM_NUMERIC_T)
		IVM_OUT("print num: %f\n", IVM_AS(obj, ivm_numeric_t)->val);
	else
		IVM_OUT("cannot print number of object of type <%s>\n", IVM_OBJECT_GET(obj, TYPE_NAME));

	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_TYPE, "print_type", N, {
	ivm_object_t *obj;

	CHECK_STACK(1);

	obj = STACK_POP();
	IVM_OUT("type: %s\n", obj ? IVM_OBJECT_GET(obj, TYPE_NAME) : "empty pointer");
	
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(PRINT_STR, "print_str", N, {
	ivm_string_object_t *str;

	CHECK_STACK(1);

	str = IVM_AS(STACK_POP(), ivm_string_object_t);

	IVM_ASSERT(IVM_IS_TYPE(str, IVM_STRING_OBJECT_T),
			   IVM_ERROR_MSG_NOT_TYPE("string", IVM_OBJECT_GET(str, TYPE_NAME)));

	IVM_OUT("%s\n", str->val);
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(OUT, "out", S, {
	IVM_OUT("%s\n", ivm_string_pool_get(STRING_POOL, ARG));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(INVOKE, "invoke", I, {
	ivm_function_object_t *obj;
	ivm_function_t *func;
	ivm_sint32_t arg_count = ARG;
	ivm_vmstack_iterator_t args;
	ivm_object_t *ret;

	CHECK_STACK(arg_count + 1);

	obj = IVM_AS(STACK_POP(), ivm_function_object_t);

	IVM_ASSERT(IVM_IS_TYPE(obj, IVM_FUNCTION_OBJECT_T),
			   IVM_ERROR_MSG_NOT_TYPE("function", IVM_OBJECT_GET(obj, TYPE_NAME)));
	
	func = ivm_function_object_getFunc(obj);
	args = STACK_CUT(arg_count);

	IVM_RUNTIME_SET(RUNTIME, IP, INSTR + 1);

	ivm_function_invoke(func, STATE,
						ivm_function_object_getClosure(obj), CORO);

	if (ivm_function_isNative(func)) {
		ret = ivm_function_callNative(func, STATE, CONTEXT,
									  IVM_FUNCTION_SET_ARG_2(arg_count, args));
		STACK_PUSH(ret ? ret : IVM_NULL_OBJ(STATE));
	} else {
		STACK_INC(arg_count);
	}

	return IVM_ACTION_INVOKE;
})

OP_GEN(YIELD, "yield", N, {
	INSTR++;
	return IVM_ACTION_YIELD;
})

OP_GEN(JUMP, "jump", I, {
	INSTR += ARG;
	return IVM_ACTION_NONE;
})

OP_GEN(JUMP_TRUE, "jump_true", I, {
	if (ivm_object_toBool(STACK_POP(), STATE)) {
		INSTR += ARG;
	} else {
		INSTR++;
	}

	return IVM_ACTION_NONE;
})

OP_GEN(JUMP_FALSE, "jump_false", I, {
	if (!ivm_object_toBool(STACK_POP(), STATE)) {
		INSTR += ARG;
	} else {
		INSTR++;
	}

	return IVM_ACTION_NONE;
})

OP_GEN(TEST1, "test1", N, {
	IVM_OUT("test1\n");
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(TEST2, "test2", I, { 
	INSTR++;
	return IVM_ACTION_NONE;
})

OP_GEN(TEST3, "test3", S, {
	IVM_OUT("morning! this is test3\n");
	IVM_OUT("string argument: %s\n", ivm_string_pool_get(STRING_POOL, ARG));
	INSTR++;

	return IVM_ACTION_NONE;
})

OP_GEN(LAST, "last", N, {
	IVM_ASSERT(0, "last opcode is executed");
	INSTR++;
	return IVM_ACTION_NONE;
})
